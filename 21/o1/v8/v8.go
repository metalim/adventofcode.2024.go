// Advent of Code 2024, Day 21: "Keypad Conundrum" — Полноценное решение с учётом вложенной активации.
//
// В задаче у нас 3 "робота"-уровня (верхний, средний, нижний) + цифровая клавиатура.
// Управление идёт сверху вниз следующим образом:
//
// 1) Пользователь нажимает одну из 5 клавиш: '^','v','<','>','A' — это команда для верхнего робота (robot3).
// 2) Если это не 'A', робот3 пытается сдвинуть свою "руку" (если там нет "дыры").
//    Если 'A', то робот3 "активируется":
//      - Если робот3 указывает на стрелку '^','v','<','>', то эта стрелка передаётся робот2.
//      - Если робот3 указывает на 'A', то идёт активация робот2:
//         * Если робот2 указывает на стрелку, она идёт роботу1.
//         * Если робот2 указывает на 'A', идёт активация робота1:
//             + Если робот1 указывает на стрелку, она двигает "руку" на цифровой клавиатуре.
//             + Если робот1 указывает на 'A', то нажимается кнопка, на которую робот1 указывает
//               (на цифровой клавиатуре это цифры 0..9 или 'A'), добавляя символ к набранной строке.
//
// Важно: в раскладке роботной клавиатуры есть "дырки", и в цифровой тоже. Нельзя даже "мелькнуть" в дырке.
//
// Нужно найти кратчайшую (по числу нажатий пользователя) последовательность, приводящую к набору кода,
// и затем умножить длину на числовую часть кода. Далее суммировать это для всех пяти кодов.
//
// ---------------------------------------------------
// Ключевая сложность: при нажатии 'A' может "пробиваться" цепочка активаций вниз на несколько уровней
// (если все роботы указывают на 'A', то получаем "нажатие цифры"). Если где-то в середине робот
// указывает на стрелку, то передаём эту стрелку следующему роботу.
// Таким образом, одно нажатие 'A' может вызвать целую серию действий до нижнего уровня.
//
// Мы реализуем BFS по состояниям следующего вида:
//   state = (pos3, pos2, pos1, typed)
// где
//   pos3 — где "рука" верхнего робота (строка "^","v","<",">","A"),
//   pos2 — где "рука" среднего робота,
//   pos1 — где "рука" нижнего робота (на цифровой клавиатуре: "0","1","2",...,"9","A","7","8","4","5","6","3"),
//   typed — какая строка уже набрана (цифры + 'A').
//
// Вершина BFS: (все позиции, набранное). Ребро BFS — одно нажатие пользователя '^','v','<','>','A'.
//
// При нажатии стрелок '^','v','<','>':
//   - Двигаем того робота, который "наверху" (robot3). Если переход в gap => отбрасываем.
//
// При нажатии 'A':
//   - См. pos3. Если pos3 в {'^','v','<','>'}, то эту стрелку пытается применить робот2.
//     Если там gap => отбрасываем. Если всё ок, меняем pos2.
//   - Если pos3 == 'A', то идём к роботу2:
//       * Если pos2 в {'^','v','<','>'}, то эту стрелку пытается применить робот1 (цифровая клавиатура).
//         Проверяем gap. Если норм, меняем pos1.
//       * Если pos2 == 'A', то идём к роботу1:
//           + Если pos1 в {'^','v','<','>'}, значит движение по цифровой клавиатуре (проверяем gap).
//           + Если pos1 == 'A' или цифра '0'..'9' или '7'.. и т.д., значит нажимаем эту кнопку => добавляем к typed.
//
// Плюс "префиксная" отсечка, чтобы не набирать неправильные символы.
// Как только typed совпадает с нужным code, возвращаем глубину (количество нажатий).
//
// Такой BFS может быстро вырасти, но префиксное ограничение (если набранная строка
// не совпадает с префиксом искомого code, отбрасываем) сильно уменьшает пространство.
// ---------------------------------------------------

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

// Верхняя/средняя раскладка ("роботная").
var robotKeypadAdj = map[string]map[string]string{
	"^": {
		"^": "",
		"v": "v",
		"<": "",
		">": "A",
	},
	"v": {
		"^": "^",
		"v": "",
		"<": "<",
		">": ">",
	},
	"<": {
		"^": "",
		"v": "v",
		"<": "",
		">": "v",
	},
	">": {
		"^": "",
		"v": "v",
		"<": "v",
		">": "",
	},
	"A": {
		"^": "",
		"v": "",
		"<": "",
		">": "",
	},
}

// Цифровая раскладка.
var digitKeypadAdj = map[string]map[string]string{
	"7": {
		"^": "",
		"v": "4",
		"<": "",
		">": "8",
	},
	"8": {
		"^": "",
		"v": "5",
		"<": "7",
		">": "9",
	},
	"9": {
		"^": "",
		"v": "6",
		"<": "8",
		">": "",
	},
	"4": {
		"^": "7",
		"v": "1",
		"<": "",
		">": "5",
	},
	"5": {
		"^": "8",
		"v": "2",
		"<": "4",
		">": "6",
	},
	"6": {
		"^": "9",
		"v": "3",
		"<": "5",
		">": "",
	},
	"1": {
		"^": "4",
		"v": "",
		"<": "",
		">": "2",
	},
	"2": {
		"^": "5",
		"v": "0",
		"<": "1",
		">": "3",
	},
	"3": {
		"^": "6",
		"v": "A",
		"<": "2",
		">": "",
	},
	"0": {
		"^": "2",
		"v": "",
		"<": "",
		">": "A",
	},
	"A": {
		"^": "3",
		"v": "",
		"<": "0",
		">": "",
	},
}

// Состояние: позиции на трёх роботах + что уже набрано.
type State struct {
	r3    string
	r2    string
	r1    string
	typed string
}

// solveCode находит длину кратчайшей последовательности нажатий, ведущей к коду `code`.
func solveCode(code string) int {
	start := State{r3: "A", r2: "A", r1: "A", typed: ""}

	// Если пустой код (редко в AoC, но вдруг) => 0
	if code == "" {
		return 0
	}

	// BFS
	queue := []State{start}
	dist := map[State]int{start: 0}
	userButtons := []string{"^", "v", "<", ">", "A"}

	for len(queue) > 0 {
		st := queue[0]
		queue = queue[1:]
		d := dist[st]

		// Проверка цели
		if st.typed == code {
			return d
		}
		// Если уже typed длиннее code или не совпадает с префиксом — отсечь
		if len(st.typed) > len(code) || !strings.HasPrefix(code, st.typed) {
			continue
		}

		// Перебираем все 5 нажатий
		for _, inp := range userButtons {
			ns, ok := nextState(st, inp)
			if !ok {
				continue
			}
			if _, used := dist[ns]; !used {
				dist[ns] = d + 1
				queue = append(queue, ns)
			}
		}
	}
	// Нет пути
	return 0
}

// nextState обрабатывает одно нажатие пользователя inp. Возвращает (новоеСостояние, true) или (State{}, false) при gap.
func nextState(st State, inp string) (State, bool) {
	r3, r2, r1, typed := st.r3, st.r2, st.r1, st.typed

	if inp != "A" {
		// Движение руки верхнего робота
		r3next := robotKeypadAdj[r3][inp]
		if r3next == "" {
			return State{}, false
		}
		return State{r3: r3next, r2: r2, r1: r1, typed: typed}, true
	}

	// inp == "A" => активация верхнего робота
	switch r3 {
	case "^", "v", "<", ">":
		// Это стрелка для робота2
		r2next := robotKeypadAdj[r2][r3]
		if r2next == "" {
			return State{}, false
		}
		return State{r3: r3, r2: r2next, r1: r1, typed: typed}, true

	case "A":
		// Активация робота2
		switch r2 {
		case "^", "v", "<", ">":
			// Это стрелка для робота1 (цифровая)
			r1next := digitKeypadAdj[r1][r2]
			if r1next == "" {
				return State{}, false
			}
			return State{r3: r3, r2: r2, r1: r1next, typed: typed}, true
		case "A":
			// Активация робота1 => "нажать кнопку r1"
			// r1 может быть '^','v','<','>','A','0'..'9'
			// - Если '^','v','<','>', тогда движение внутри digitKeypad
			//   (но по условию раскладки: при r1=='^'... — такого в digitKeypad нет,
			//    но давайте формально обработаем, если бы было).
			// - Если '0'..'9' или 'A' => добавить к typed
			// В нашей раскладке robotKeypadAdj есть '^','v','<','>', а digitKeypadAdj — только "0..9","A".
			// Но "A" в digitKeypad — это реальная кнопка.
			// Считаем, что если r1 in {"0","1","2","3","4","5","6","7","8","9","A"}, то добавляем к typed.
			// Иначе, если оно в {'^','v','<','>'}, двигаем (но это нестандартно) —
			//   теоретически digitKeypadAdj["^"][...] у нас нет, => будет gap => false.

			// Проверяем, не стрелка ли это.
			if _, isRobotKey := robotKeypadAdj[r1]; isRobotKey {
				// Тогда пытаемся движение
				// Но в digitKeypadAdj точно нет ключа "^","v","<",">" => будет ""
				return State{}, false
			} else {
				// Значит '0'..'9' или 'A'
				newTyped := typed + r1
				return State{r3: r3, r2: r2, r1: r1, typed: newTyped}, true
			}

		default:
			return State{}, false
		}

	default:
		return State{}, false
	}
}

// parseNumericPart выдирает число из строки вида "029A" => 29. Если только нули => 0.
func parseNumericPart(code string) int {
	s := strings.TrimSuffix(code, "A")
	s = strings.TrimLeft(s, "0")
	if s == "" {
		return 0
	}
	n, _ := strconv.Atoi(s)
	return n
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <input_file>")
		return
	}

	startAll := time.Now()

	inputFile := os.Args[1]
	f, err := os.Open(inputFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var codes []string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if line != "" {
			codes = append(codes, line)
		}
	}
	if err := sc.Err(); err != nil {
		panic(err)
	}

	if len(codes) == 0 {
		fmt.Println("No codes in input.")
		return
	}

	// Part 1
	startPart1 := time.Now()
	sumComplexity := 0
	for _, code := range codes {
		seqLen := solveCode(code)
		numVal := parseNumericPart(code)
		sumComplexity += seqLen * numVal
	}
	tPart1 := time.Since(startPart1).Seconds()
	fmt.Printf("Part 1: %d (time %.4fs)\n", sumComplexity, tPart1)

	// Part 2: не реализован
	startPart2 := time.Now()
	fmt.Printf("Part 2: not implemented (time %.4fs)\n", time.Since(startPart2).Seconds())

	_ = time.Since(startAll)
}
