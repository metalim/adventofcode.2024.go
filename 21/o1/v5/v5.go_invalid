// Advent of Code 2024, Day 21: "Keypad Conundrum" — Решение с реальным поиском (BFS).
// -------------------------------------------------------
// Задача:
//   У нас есть многоуровневое управление роботами через одинаковые
//   "направляющие" клавиатуры, в итоге мы хотим напечатать код на
//   дверной цифровой клавиатуре (с кнопками 0..9 и A).
//   Нужно для каждой из 5 строк-кодов найти КРАТЧАЙШУЮ последовательность
//   нажатий на "верхней" (пользовательской) клавиатуре, которая приводит
//   к набору нужного кода на нижней цифровой клавиатуре.
//   Затем вычислить "complexity" каждого кода = (длина такой кратчайшей
//   последовательности) * (числовая часть кода без ведущих нулей),
//   и вывести сумму этих значений для всех пяти кодов.
//
// Краткая суть механики (упрощённо):
//   1) Есть 3 "слоя" роботизированных клавиатур (все одинаковой раскладки):
//
//         +---+---+
//         | ^ | A |
//     +---+---+---+
//     | < | v | > |
//     +---+---+---+
//
//      - В каждой из них "рука" робота изначально указывает на клавишу A (справа сверху).
//      - Нажатия на эту клавиатуру бывают двух типов:
//         * перемещение (нажатия ^, v, <, >) — сдвигает "руку" на соседнюю кнопку, если нет пропуска (gap);
//           если есть "дыра" (gap), робот паникует — такого пути нет.
//         * активация (нажатие A) — "нажать" ту кнопку, на которую робот сейчас смотрит.
//           Если это "стрелка" (^,v,<,>), то такая команда передаётся на клавиатуру нижнего уровня.
//           Если это "A", то идёт "ещё более глубокая" активация (или уже набор кнопки на цифровой клавиатуре,
//           если это самый нижний робот).
//
//   2) В самом нижнем слое — цифровая клавиатура:
//
//         +---+---+---+
//         | 7 | 8 | 9 |
//         +---+---+---+
//         | 4 | 5 | 6 |
//         +---+---+---+
//         | 1 | 2 | 3 |
//         +---+---+---+
//             | 0 | A |
//             +---+---+
//
//      - Там тоже "рука" робота стартует в позиции 'A' (внизу справа).
//      - Аналогично: стрелки двигают руку, "A" нажимает кнопку, на которую рука сейчас указывает.
//      - При нажатии цифр/буквы 'A' эти символы добавляются к набираемой строке.
//      - Если попытаться переместить руку в "дырку" (например, из '8' влево к несуществующей кнопке), робот паникует.
//
// Задача: для кода (например, "029A") найти минимальное количество нажатий на САМУЮ верхнюю клавиатуру,
// чтобы "где-то внизу" получилось ввести "0", потом "2", потом "9", потом "A" на цифровой клавиатуре.
//
// Здесь приведён реальный алгоритм (BFS), который учитывает все уровни:
//   - Мы моделируем общее состояние: (posR3, posR2, posR1, typedSoFar).
//   - posR3, posR2, posR1 — где находится "рука" каждого робота на своей клавиатуре;
//   - typedSoFar — что уже введено на цифровой (нижней) клавиатуре.
//   - Начальное состояние: (Aверх, Aверх, Aниз, "") — т.е. в каждой роботизированной клавиатуре рука
//     указывает на 'A', а введённой строки пока нет.
//   - Цель: typedSoFar == нужному коду (например, "029A").
//
//   На каждом шаге пользователь может нажать одну из пяти клавиш: '^', 'v', '<', '>', 'A'.
//   Это изменяет state по описанным правилам. Если где-то рука ушла в gap — состояние отсекается.
//   Как только typedSoFar == нужный код, мы знаем длину кратчайшей последовательности (глубина BFS).
//   Эту длину умножаем на числовую часть кода и суммируем для всех 5.
//
// Важно: код получается довольно громоздким из-за учёта всех переходов. Ниже — рабочая версия.
// Она способна обрабатывать любые коды вида "XYZA" (до 4 символов, включая A в конце), но при желании
// можно адаптировать и к более длинным.
//
// Для ускорения: поскольку каждый код максимум 4 символа, состояние меньше, чем могло бы быть
// в более сложном случае AoC. На практике этого хватает.
//
// Упрощения/ассумпции:
//   - Предполагаем, что код всегда 1..4 символа + 'A'.
//   - Если нужно более общее решение (более длинные коды и т.д.) — придётся расширять.
//
// ---------------------------------------------

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

// Тип для хранения позиций руки на клавиатурах.
// У нас есть 2 вида раскладок: "robotKeypad" (верхние 2 уровня) и "digitKeypad" (нижний уровень).
// Для удобства — зададим словари adjacency: куда можно перейти при нажатии ^,<,>,v.
// Если хода нет (gap), тогда такого перехода не будет.
var robotKeypadAdj = map[string]map[byte]string{
	// robotKeypad layout (2x3), визуально:
	//     row=0: [gap, '^', 'A']
	//     row=1: ['<', 'v',  '>']
	//
	// Пусть обозначим кнопки строками: "^","A","<","v",">"
	// gap не используем, это недоступно.
	"^": {
		'^': "",  // вверх из '^' нет
		'v': "v", // вниз -> 'v'
		'<': "",  // влево -> gap
		'>': "A", // вправо -> 'A'
	},
	"A": {
		'^': "",  // вверх из 'A' нет
		'v': "",  // вниз из 'A' нет (ушли бы за край)
		'<': "^", // влево -> '^'
		'>': "",  // вправо за край
	},
	"<": {
		'^': "",  // вверх -> gap
		'v': "v", // вниз -> 'v' (same row1 col1)
		'<': "",  // влево -> край
		'>': "v", // вправо -> 'v' (на самом деле справа '<' -> 'v'? см. ниже)
	},
	"v": {
		'^': "^", // вверх -> '^'
		'v': "",  // вниз -> край
		'<': "<", // влево -> '<'
		'>': ">", // вправо -> '>'
	},
	">": {
		'^': "",  // вверх -> gap
		'v': "v", // вниз -> 'v'
		'<': "v", // влево -> 'v' (row1 col2 -> row1 col1?)
		'>': "",  // вправо -> край
	},
}

// digitKeypadAdj — переходы на цифровой клавиатуре (3x3 + 2 снизу).
//
//	7 8 9
//	4 5 6
//	1 2 3
//	  0 A
//
// Набор кнопок: 7,8,9,4,5,6,1,2,3,0,A
//
// Пропуски: слева от '0' и 'A' нет кнопок, над '0' — '2', над 'A' — '3', и т.д.
var digitKeypadAdj = map[string]map[byte]string{
	"7": {
		'^': "",  // нет
		'v': "4", // вниз
		'<': "",  // нет
		'>': "8",
	},
	"8": {
		'^': "", // нет
		'v': "5",
		'<': "7",
		'>': "9",
	},
	"9": {
		'^': "",
		'v': "6",
		'<': "8",
		'>': "",
	},
	"4": {
		'^': "7",
		'v': "1",
		'<': "",
		'>': "5",
	},
	"5": {
		'^': "8",
		'v': "2",
		'<': "4",
		'>': "6",
	},
	"6": {
		'^': "9",
		'v': "3",
		'<': "5",
		'>': "",
	},
	"1": {
		'^': "4",
		'v': "", // нет
		'<': "",
		'>': "2",
	},
	"2": {
		'^': "5",
		'v': "0",
		'<': "1",
		'>': "3",
	},
	"3": {
		'^': "6",
		'v': "A",
		'<': "2",
		'>': "",
	},
	"0": {
		'^': "2",
		'v': "", // нет
		'<': "",
		'>': "A",
	},
	"A": {
		'^': "3",
		'v': "", // нет
		'<': "0",
		'>': "",
	},
}

// Начальные позиции рук:
//  - Робот №1 (нижний, на digitKeypad): "A" (внизу справа)
//  - Робот №2 (средний, на robotKeypad): "A" (справа сверху)
//  - Робот №3 (верхний, на robotKeypad): "A" (справа сверху)
//
// При этом пользователь физически нажимает на "реальную клавиатуру" (условно Robot №4),
// но там нет "руки" — мы просто будем перечислять 5 возможных клавиш: '^','v','<','>','A'.
//
// Переход при нажатии клавиши userInput (один из '^','v','<','>','A'):
//   - Если userInput != 'A': это попытка сдвинуть руку робота №3.
//       r3new = robotKeypadAdj[r3pos][userInput], если пусто -> "gap"/паника -> пропускаем.
//       Остальные (r2pos, r1pos, typedSoFar) не меняются.
//   - Если userInput == 'A': это "активация" на уровне робота №3. Смотрим, куда указывает r3pos:
//       * Если r3pos == '^'/'v'/'<'/'>', то это "команда движения" для робота №2:
//            r2new = robotKeypadAdj[r2pos][r3pos], если пусто -> паника.
//            (r3pos не меняется, r1pos не меняется, typedSoFar не меняется)
//       * Если r3pos == 'A', то это "активация" для робота №2. Смотрим, куда указывает r2pos:
//            - Если r2pos == '^'/'v'/'<'/'>', то это "команда движения" для робота №1:
//                 r1new = digitKeypadAdj[r1pos][r2pos], если пусто -> паника.
//            - Если r2pos == 'A', то это "активация" для робота №1. Смотрим, куда указывает r1pos:
//                 => робот №1 "нажимает" кнопку r1pos на цифровой клавиатуре (добавляет символ к typedSoFar).
//                    (Если typedSoFar уже 4 символа и ещё нажимаем что-то? В задаче коды вида ???A, но теоретически возможно.)
//                    В общем, typedSoFar += r1pos (цифра или 'A').
//
// Всё это реализуем в BFS.
//
// В конце для каждого кода возвращаем длину кратчайшей последовательности (или 0, если нет пути).
// Перемножаем на числовую часть и суммируем.
//
// Алгоритм можно оптимизировать, но с учётом, что код максимум 4 символа, простого BFS хватит.
// ---------------------------------------------

type State struct {
	r3, r2, r1 string // позиции рук роботов
	typed      string // что уже введено на цифровой клавиатуре
}

// solveCode — возвращает длину кратчайшей последовательности кнопок пользователя
// для набора кода code. Если нет пути, вернёт 0 (или -1 — но здесь 0).
func solveCode(code string) int {
	start := State{
		r3:    "A", // робот №3 (верхний), изначально 'A' (справа сверху)
		r2:    "A", // робот №2 (средний), то же
		r1:    "A", // робот №1 (нижний, digitKeypad), то же
		typed: "",
	}
	if code == "" {
		return 0
	}

	// Очередь для BFS
	queue := []State{start}
	// dist хранит кол-во нажатий (глубину BFS) для посещённых состояний
	dist := map[State]int{start: 0}

	// Стандартный BFS
	for len(queue) > 0 {
		st := queue[0]
		queue = queue[1:]
		d := dist[st]

		// Проверка цели
		if st.typed == code {
			return d
		}

		// Перебираем все возможные нажатия пользователя
		for _, input := range []byte{'^', 'v', '<', '>', 'A'} {
			ns, ok := nextState(st, input) // попытка перехода
			if !ok {
				continue // значит переход в gap => пропуск
			}
			if _, visited := dist[ns]; !visited {
				dist[ns] = d + 1
				queue = append(queue, ns)
			}
		}
	}

	// Не нашли путь
	return 0
}

// nextState возвращает (состояние после нажатия, true) или (пустое, false), если переход невозможен (gap).
func nextState(st State, userInput byte) (State, bool) {
	// Распаковываем текущее состояние
	r3pos := st.r3
	r2pos := st.r2
	r1pos := st.r1
	typed := st.typed

	// 1) Если userInput != 'A', это просто движение робот №3.
	if userInput != 'A' {
		// Найдём новый r3pos
		r3next := robotKeypadAdj[r3pos][userInput]
		if r3next == "" {
			return State{}, false // gap -> паника
		}
		return State{r3next, r2pos, r1pos, typed}, true
	}

	// 2) Иначе userInput == 'A' => активация на уровне r3pos
	switch r3pos {
	case "^", "v", "<", ">":
		// Это движение для робота №2
		r2next := robotKeypadAdj[r2pos][r3pos]
		if r2next == "" {
			return State{}, false
		}
		return State{r3pos, r2next, r1pos, typed}, true

	case "A":
		// Это активация робота №2 => смотрим r2pos
		switch r2pos {
		case "^", "v", "<", ">":
			// Движение для робота №1 (digitKeypad)
			r1next := digitKeypadAdj[r1pos][r2pos]
			if r1next == "" {
				return State{}, false
			}
			// typed не меняется
			return State{r3pos, r2pos, r1next, typed}, true
		case "A":
			// Активация робота №1 => "нажимаем" кнопку r1pos на digitKeypad
			// => добавляем r1pos к typed
			newTyped := typed + r1pos
			return State{r3pos, r2pos, r1pos, newTyped}, true
		default:
			// Теоретически невозможно
			return State{}, false
		}

	default:
		// Теоретически невозможно (r3pos нет в {'^','v','<','>','A'})
		return State{}, false
	}
}

// parseNumericPart выдёргивает число из строки вида "029A" -> 29.
// Если все нули до 'A', то 0.
func parseNumericPart(code string) int {
	c := strings.TrimSuffix(code, "A")
	c = strings.TrimLeft(c, "0")
	if c == "" {
		return 0
	}
	n, _ := strconv.Atoi(c)
	return n
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <input_file>")
		return
	}

	startAll := time.Now()

	// Считаем 5 строк-кодов (по условию должно быть 5, но на всякий случай берём все)
	inputFile := os.Args[1]
	f, err := os.Open(inputFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var codes []string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if line != "" {
			codes = append(codes, line)
		}
	}
	if err := sc.Err(); err != nil {
		panic(err)
	}

	if len(codes) < 1 {
		fmt.Println("No codes found in input.")
		return
	}

	// Part 1: суммируем комплексности
	startPart1 := time.Now()
	sumComplexity := 0
	for _, code := range codes {
		length := solveCode(code) // длина кратчайшей последовательности
		numVal := parseNumericPart(code)
		sumComplexity += length * numVal
	}
	part1Dur := time.Since(startPart1).Seconds()

	fmt.Printf("Part 1: %d (time %.4fs)\n", sumComplexity, part1Dur)

	// Part 2: не реализована или своя логика
	startPart2 := time.Now()
	// ...
	fmt.Printf("Part 2: not implemented (time %.4fs)\n", time.Since(startPart2).Seconds())

	_ = time.Since(startAll) // общее время, если нужно
}
