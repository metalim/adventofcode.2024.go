/*
➜ go run ./o1/v5 sample.txt
[DEBUG] Shifted Box from (4, 3) to (4, 2)
[DEBUG] Shifted Box from (6, 4) to (6, 5)
[DEBUG] Shifted Box from (6, 5) to (6, 6)
[DEBUG] Shifted Box from (5, 5) to (4, 5)
[DEBUG] Shifted Box from (6, 7) to (6, 8)
[DEBUG] Shifted Box from (6, 6) to (6, 7)
[DEBUG] Shifted Box from (7, 5) to (7, 4)
[DEBUG] Shifted Box from (8, 5) to (8, 4)
[DEBUG] Shifted Box from (8, 4) to (8, 3)
[DEBUG] Shifted Box from (7, 4) to (6, 4)
[DEBUG] Shifted Box from (8, 3) to (8, 2)
[DEBUG] Shifted Box from (8, 2) to (8, 1)
[DEBUG] Shifted Box from (7, 2) to (6, 2)
[DEBUG] Shifted Box from (7, 3) to (7, 4)
[DEBUG] Shifted Box from (7, 4) to (7, 5)
[DEBUG] Shifted Box from (6, 4) to (5, 4)
[DEBUG] Shifted Box from (5, 1) to (4, 1)
[DEBUG] Shifted Box from (6, 1) to (5, 1)
[DEBUG] Shifted Box from (5, 4) to (5, 5)
[DEBUG] Shifted Box from (5, 5) to (5, 6)
[DEBUG] Shifted Box from (5, 6) to (5, 7)
[DEBUG] Shifted Box from (4, 5) to (4, 4)
[DEBUG] Shifted Box from (4, 4) to (4, 3)
[DEBUG] Shifted Box from (3, 2) to (3, 1)
[DEBUG] Shifted Box from (3, 3) to (3, 2)
[DEBUG] Shifted Box from (7, 5) to (7, 4)
[DEBUG] Shifted Box from (7, 4) to (7, 3)
[DEBUG] Shifted Box from (7, 3) to (7, 2)
[DEBUG] Shifted Box from (7, 2) to (7, 1)
[DEBUG] Shifted Box from (5, 7) to (5, 8)
[DEBUG] Shifted Box from (7, 7) to (8, 7)
[DEBUG] Shifted Box from (6, 7) to (7, 7)
[DEBUG] Shifted Box from (3, 6) to (2, 6)
[DEBUG] Shifted Box from (4, 7) to (5, 7)
[DEBUG] Shifted Box from (2, 7) to (1, 7)
[DEBUG] Shifted Box from (3, 8) to (4, 8)
[DEBUG] Shifted Box from (7, 8) to (8, 8)
[DEBUG] Shifted Box from (6, 8) to (7, 8)
[DEBUG] Shifted Box from (5, 8) to (6, 8)
[DEBUG] Shifted Box from (4, 8) to (5, 8)
[DEBUG] Shifted Box from (4, 3) to (3, 3)
[DEBUG] Shifted Box from (3, 3) to (4, 3)
[DEBUG] Shifted Box from (4, 3) to (5, 3)
[DEBUG] Shifted Box from (5, 3) to (6, 3)
[DEBUG] Shifted Box from (1, 3) to (1, 2)
[DEBUG] Shifted Box from (2, 6) to (2, 7)
[DEBUG] Shifted Box from (6, 3) to (7, 3)
[DEBUG] Shifted Box from (6, 2) to (6, 1)
[DEBUG] Shifted Box from (7, 3) to (7, 4)
[DEBUG] Shifted Box from (5, 7) to (6, 7)
[DEBUG] Shifted Box from (7, 4) to (8, 4)
[DEBUG] Shifted Box from (2, 7) to (2, 6)
[DEBUG] Shifted Box from (8, 4) to (8, 3)
[DEBUG] Shifted Box from (8, 3) to (8, 2)
[DEBUG] Shifted Box from (2, 6) to (2, 7)
[DEBUG] Shifted Box from (2, 7) to (2, 6)
[DEBUG] Shifted Box from (2, 6) to (2, 5)
[DEBUG] Shifted Box from (2, 5) to (2, 4)
[DEBUG] Shifted Box from (2, 4) to (1, 4)
[DEBUG] Shifted Box pair from (6, 8)-(6, 9) to (7, 8)-(7, 9)
[DEBUG] Shifted Box pair from (5, 10)-(5, 11) to (4, 10)-(4, 11)
[DEBUG] Shifted Box pair from (7, 7)-(7, 8) to (8, 7)-(8, 8)
[DEBUG] Shifted Box pair from (7, 4)-(7, 5) to (8, 4)-(8, 5)
[DEBUG] Shifted Box pair from (5, 2)-(5, 3) to (4, 2)-(4, 3)
[DEBUG] Recursively shifted Box pair from (6, 2)-(6, 3) to (5, 2)-(5, 3)
[DEBUG] Shifted Box pair from (3, 6)-(3, 7) to (2, 6)-(2, 7)
[DEBUG] Recursively shifted Box pair from (4, 6)-(4, 7) to (3, 6)-(3, 7)
[DEBUG] Shifted Box pair from (4, 10)-(4, 11) to (3, 10)-(3, 11)
[DEBUG] Shifted Box pair from (3, 12)-(3, 13) to (2, 12)-(2, 13)
[DEBUG] Shifted Box pair from (4, 14)-(4, 15) to (5, 14)-(5, 15)
[DEBUG] Shifted Box pair from (7, 14)-(7, 15) to (8, 14)-(8, 15)
[DEBUG] Recursively shifted Box pair from (6, 14)-(6, 15) to (7, 14)-(7, 15)
[DEBUG] Recursively shifted Box pair from (5, 14)-(5, 15) to (6, 14)-(6, 15)
[DEBUG] Shifted Box pair from (2, 14)-(2, 15) to (1, 14)-(1, 15)
[DEBUG] Shifted Box pair from (4, 2)-(4, 3) to (3, 2)-(3, 3)
[DEBUG] Recursively shifted Box pair from (5, 2)-(5, 3) to (4, 2)-(4, 3)
[DEBUG] Shifted Box pair from (3, 2)-(3, 3) to (2, 2)-(2, 3)
[DEBUG] Recursively shifted Box pair from (4, 2)-(4, 3) to (3, 2)-(3, 3)
[DEBUG] Shifted Box pair from (2, 2)-(2, 3) to (1, 2)-(1, 3)
[DEBUG] Recursively shifted Box pair from (3, 2)-(3, 3) to (2, 2)-(2, 3)
[DEBUG] Shifted Box pair from (3, 4)-(3, 5) to (2, 4)-(2, 5)
[DEBUG] Shifted Box pair from (2, 4)-(2, 5) to (1, 4)-(1, 5)
[DEBUG] Shifted Box pair from (3, 10)-(3, 11) to (2, 10)-(2, 11)
Part 1: 10092   in 471.75µs
Part 2: 8094    in 148.125µs

[DEBUG] Box positions after Part 2 simulation:
Box at row 1, column 2 (GPS: 102)
Box at row 1, column 4 (GPS: 104)
Box at row 1, column 6 (GPS: 106)
Box at row 1, column 12 (GPS: 112)
Box at row 1, column 14 (GPS: 114)
Box at row 1, column 16 (GPS: 116)
Box at row 2, column 2 (GPS: 202)
Box at row 2, column 6 (GPS: 206)
Box at row 2, column 10 (GPS: 210)
Box at row 2, column 12 (GPS: 212)
Box at row 3, column 6 (GPS: 306)
Box at row 3, column 16 (GPS: 316)
Box at row 6, column 14 (GPS: 614)
Box at row 7, column 9 (GPS: 709)
Box at row 7, column 14 (GPS: 714)
Box at row 7, column 16 (GPS: 716)
Box at row 8, column 4 (GPS: 804)
Box at row 8, column 7 (GPS: 807)
Box at row 8, column 10 (GPS: 810)
Box at row 8, column 14 (GPS: 814)

ты уверен, что понял задачу правильно? как ты отличаешь левую часть коробки от правой части коробки? я не вижу этого в коде
*/

package main

import (
	"fmt"
	"os"
	"strings"
	"time"
)

// Типы плиток на карте
type Tile int

const (
	Wall Tile = iota
	Empty
	BoxLeft
	BoxRight
	Robot
)

// Координаты на карте
type Coord struct {
	R, C int
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go input.txt")
		return
	}
	inputFile := os.Args[1]
	data, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}
	lines := strings.Split(strings.ReplaceAll(string(data), "\r", ""), "\n")

	// Разделяем карту и ходы по первой пустой строке
	var mapLines []string
	var movesLines []string
	readingMap := true
	for _, l := range lines {
		if strings.TrimSpace(l) == "" {
			readingMap = false
			continue
		}
		if readingMap {
			mapLines = append(mapLines, l)
		} else {
			movesLines = append(movesLines, l)
		}
	}
	movesStr := strings.ReplaceAll(strings.Join(movesLines, ""), "\n", "")
	movesStr = strings.ReplaceAll(movesStr, " ", "")

	// Парсим карту
	originalMap, robotPos := parseMap(mapLines)

	// Решаем часть 1
	start1 := time.Now()
	finalMap1 := simulate(copyMap(originalMap), robotPos, movesStr, false)
	res1 := calcSum(finalMap1, false)
	dur1 := time.Since(start1)

	// Решаем часть 2 (масштабирование карты)
	expandedMap, expandedRobotPos := expandMap(originalMap)
	start2 := time.Now()
	finalMap2 := simulate(copyMap(expandedMap), expandedRobotPos, movesStr, true)
	res2 := calcSum(finalMap2, true)
	dur2 := time.Since(start2)

	// Выводим результаты
	fmt.Printf("Part 1: %d\tin %v\n", res1, dur1)
	fmt.Printf("Part 2: %d\tin %v\n", res2, dur2)

	// Отладочный вывод: список координат коробок для части 2
	fmt.Println("\n[DEBUG] Box positions after Part 2 simulation:")
	boxPositions := getBoxPositions(finalMap2, true)
	for _, pos := range boxPositions {
		fmt.Printf("Box at row %d, column %d (GPS: %d)\n", pos.R, pos.C, 100*pos.R+pos.C)
	}
}

// Функция для копирования карты
func copyMap(grid [][]Tile) [][]Tile {
	h := len(grid)
	w := len(grid[0])
	newGrid := make([][]Tile, h)
	for r := 0; r < h; r++ {
		newGrid[r] = make([]Tile, w)
		copy(newGrid[r], grid[r])
	}
	return newGrid
}

// Парсинг карты из строк
func parseMap(lines []string) ([][]Tile, Coord) {
	h := len(lines)
	w := len(lines[0])
	grid := make([][]Tile, h)
	var robot Coord
	for r := 0; r < h; r++ {
		grid[r] = make([]Tile, w)
		for c := 0; c < w; c++ {
			switch lines[r][c] {
			case '#':
				grid[r][c] = Wall
			case '.':
				grid[r][c] = Empty
			case 'O':
				// В исходной карте коробки одиночные
				grid[r][c] = BoxLeft
			case '@':
				grid[r][c] = Robot
				robot = Coord{r, c}
			default:
				grid[r][c] = Empty
			}
		}
	}
	// Преобразуем одиночные коробки в пары, если они рядом
	for r := 0; r < h; r++ {
		for c := 0; c < w-1; c++ {
			if grid[r][c] == BoxLeft && grid[r][c+1] == BoxLeft {
				grid[r][c] = BoxLeft
				grid[r][c+1] = BoxRight
			}
		}
	}
	return grid, robot
}

// Масштабирование карты для части 2
func expandMap(original [][]Tile) ([][]Tile, Coord) {
	h := len(original)
	w := len(original[0])
	newW := w * 2
	newMap := make([][]Tile, h)
	var robot Coord
	for r := 0; r < h; r++ {
		newMap[r] = make([]Tile, newW)
		col := 0
		for c := 0; c < w; c++ {
			switch original[r][c] {
			case Wall:
				// ## -> Wall, Wall
				newMap[r][col] = Wall
				newMap[r][col+1] = Wall
				col += 2
			case Empty:
				// .. -> Empty, Empty
				newMap[r][col] = Empty
				newMap[r][col+1] = Empty
				col += 2
			case BoxLeft:
				// [] -> BoxLeft, BoxRight
				newMap[r][col] = BoxLeft
				newMap[r][col+1] = BoxRight
				col += 2
			case BoxRight:
				// Already part of a pair, skip
				newMap[r][col] = BoxLeft
				newMap[r][col+1] = BoxRight
				col += 2
			case Robot:
				// @. -> Robot, Empty
				newMap[r][col] = Robot
				newMap[r][col+1] = Empty
				robot = Coord{r, col}
				col += 2
			default:
				// Заполняем пустыми, если встретили неизвестный символ
				newMap[r][col] = Empty
				newMap[r][col+1] = Empty
				col += 2
			}
		}
	}
	return newMap, robot
}

// Симуляция перемещений робота
func simulate(grid [][]Tile, robot Coord, moves string, expanded bool) [][]Tile {
	// for idx, m := range moves {
	for _, m := range moves {
		dr, dc := 0, 0
		switch m {
		case '^':
			dr = -1
		case 'v':
			dr = 1
		case '<':
			dc = -1
		case '>':
			dc = 1
		}
		tryMove(grid, &robot, dr, dc, expanded)

		// Отладочный вывод после каждого шага (можно раскомментировать для подробной отладки)
		/*
			fmt.Printf("\n[DEBUG] After move %d (%c):\n", idx+1, m)
			printMap(grid, expanded)
		*/
	}
	return grid
}

// Попытка перемещения робота
func tryMove(grid [][]Tile, robot *Coord, dr, dc int, expanded bool) {
	R, C := robot.R, robot.C
	nr, nc := R+dr, C+dc
	if nr < 0 || nr >= len(grid) || nc < 0 || nc >= len(grid[0]) {
		return
	}
	if grid[nr][nc] == Wall {
		return
	}
	if grid[nr][nc] == Empty {
		// Двигаем робота
		grid[R][C] = Empty
		grid[nr][nc] = Robot
		robot.R, robot.C = nr, nc
		return
	}
	if grid[nr][nc] == BoxLeft || grid[nr][nc] == BoxRight {
		// Определяем, является ли эта коробка левой частью пары
		isLeft := grid[nr][nc] == BoxLeft
		if !isLeft {
			// Если правая часть коробки, пытаемся сдвинуть всю пару
			if nc-1 >= 0 && grid[nr][nc-1] == BoxLeft {
				isLeft = true
				nc = nc - 1
			} else {
				// Нельзя сдвинуть коробку, так как правая часть не имеет левой
				return
			}
		}
		if pushBoxes(grid, nr, nc, dr, dc, expanded) {
			// Если получилось сдвинуть коробки, двигаем робота
			grid[R][C] = Empty
			grid[nr][nc] = Robot
			robot.R, robot.C = nr, nc
		}
	}
}

// Функция для сдвига коробок
func pushBoxes(grid [][]Tile, r, c, dr, dc int, expanded bool) bool {
	h, w := len(grid), len(grid[0])

	if expanded {
		// В расширенном режиме коробки представлены парами BoxLeft и BoxRight
		// Проверяем, что (r,c) - BoxLeft и (r,c+1) - BoxRight
		if c+1 >= w || grid[r][c] != BoxLeft || grid[r][c+1] != BoxRight {
			return false
		}

		// Целевые позиции для пары
		tr1, tc1 := r+dr, c+dc
		tr2, tc2 := r+dr, c+dc+1

		// Проверяем границы
		if tr1 < 0 || tr1 >= h || tc1 < 0 || tc1+1 >= w {
			return false
		}

		// Проверяем, свободны ли целевые позиции
		if grid[tr1][tc1] == Empty && grid[tr2][tc2] == Empty {
			// Сдвигаем пару
			grid[tr1][tc1] = BoxLeft
			grid[tr2][tc2] = BoxRight
			grid[r][c] = Empty
			grid[r][c+1] = Empty
			// Отладочный вывод
			fmt.Printf("[DEBUG] Shifted Box pair from (%d, %d)-(%d, %d) to (%d, %d)-(%d, %d)\n",
				r, c, r, c+1, tr1, tc1, tr2, tc2)
			return true
		}

		// Если целевые позиции заняты коробками, пытаемся сдвинуть их рекурсивно
		if grid[tr1][tc1] == BoxLeft && grid[tr2][tc2] == BoxRight {
			if pushBoxes(grid, tr1, tc1, dr, dc, expanded) {
				// После успешного сдвига существующих коробок, сдвигаем текущую пару
				grid[tr1][tc1] = BoxLeft
				grid[tr2][tc2] = BoxRight
				grid[r][c] = Empty
				grid[r][c+1] = Empty
				// Отладочный вывод
				fmt.Printf("[DEBUG] Recursively shifted Box pair from (%d, %d)-(%d, %d) to (%d, %d)-(%d, %d)\n",
					r, c, r, c+1, tr1, tc1, tr2, tc2)
				return true
			}
		}

		// В противном случае, не можем сдвинуть коробки
		return false
	} else {
		// В обычном режиме коробки одиночные
		// Определяем цепочку коробок
		boxes := []Coord{{r, c}}
		cr, cc := r+dr, c+dc
		for cr >= 0 && cr < h && cc >= 0 && cc < w && (grid[cr][cc] == BoxLeft || grid[cr][cc] == BoxRight) {
			// Если встретили BoxRight, считаем только если есть соответствующий BoxLeft
			if grid[cr][cc] == BoxRight {
				if cc-1 >= 0 && grid[cr][cc-1] == BoxLeft {
					boxes = append(boxes, Coord{cr, cc - 1})
					cr += dr
					cc += dc
				} else {
					// Неправильная пара, остановка
					break
				}
			} else {
				boxes = append(boxes, Coord{cr, cc})
				cr += dr
				cc += dc
			}
		}

		// Проверяем, можно ли сдвинуть последний коробку
		if cr < 0 || cr >= h || cc < 0 || cc >= w {
			return false
		}
		if grid[cr][cc] == Wall || grid[cr][cc] == Robot {
			return false
		}
		if grid[cr][cc] == BoxLeft || grid[cr][cc] == BoxRight {
			if !pushBoxes(grid, cr, cc, dr, dc, expanded) {
				return false
			}
		}

		// Сдвигаем коробки с конца
		for i := len(boxes) - 1; i >= 0; i-- {
			br, bc := boxes[i].R, boxes[i].C
			if grid[br][bc] == BoxLeft {
				grid[br+dr][bc+dc] = BoxLeft
				grid[br][bc] = Empty
				// Правую часть коробки
				grid[br+dr][bc+dc+1] = BoxRight
				grid[br][bc+1] = Empty
				// Отладочный вывод
				fmt.Printf("[DEBUG] Shifted Box from (%d, %d) to (%d, %d)\n", br, bc, br+dr, bc+dc)
			}
		}
		return true
	}
}

// Вычисление суммы GPS координат
func calcSum(grid [][]Tile, expanded bool) int {
	sum := 0
	h, w := len(grid), len(grid[0])
	if !expanded {
		// Каждая коробка - единичный tile
		for r := 0; r < h; r++ {
			for c := 0; c < w; c++ {
				if grid[r][c] == BoxLeft {
					sum += 100*r + c
				}
			}
		}
	} else {
		// Коробки двойные по горизонтали
		// Считаем только левую часть каждой пары коробок
		for r := 0; r < h; r++ {
			for c := 0; c < w; c++ {
				if grid[r][c] == BoxLeft && (c+1 < w && grid[r][c+1] == BoxRight) {
					sum += 100*r + c
				}
			}
		}
	}
	return sum
}

// Получение списка координат коробок (левых частей в расширенном режиме)
func getBoxPositions(grid [][]Tile, expanded bool) []Coord {
	var positions []Coord
	h, w := len(grid), len(grid[0])
	if !expanded {
		// Каждая коробка - единичный tile
		for r := 0; r < h; r++ {
			for c := 0; c < w; c++ {
				if grid[r][c] == BoxLeft {
					positions = append(positions, Coord{r, c})
				}
			}
		}
	} else {
		// Коробки двойные по горизонтали
		for r := 0; r < h; r++ {
			for c := 0; c < w-1; c++ {
				if grid[r][c] == BoxLeft && grid[r][c+1] == BoxRight {
					positions = append(positions, Coord{r, c})
				}
			}
		}
	}
	return positions
}

// Отладочный вывод карты (необязательно, можно раскомментировать в simulate для подробной отладки)
func printMap(grid [][]Tile, expanded bool) {
	for _, row := range grid {
		for _, tile := range row {
			switch tile {
			case Wall:
				fmt.Print("#")
			case Empty:
				fmt.Print(".")
			case BoxLeft:
				fmt.Print("[")
			case BoxRight:
				fmt.Print("]")
			case Robot:
				fmt.Print("@")
			}
		}
		fmt.Println()
	}
}
